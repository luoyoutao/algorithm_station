# 异或运算
a ^ a = 0，这很重要，很多题目可以用这个巧解。  
# 交换两个数a、b的值
a = a ^ b  
b = a ^ b  
a = a ^ b  
不过需要注意，a、b不能指向内存的同一位置，比如arr\[i\]和arr\[j\]交换值时，i不能和j相等。  
# lowbit()
lowbit(x) = x & -x;  // 返回x最后一个1包括之后的零，常用于计算一个数二进制中1的位数。  
# 相关题目
1、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数  
int ans = 0，用ans与所有数异或，最后的ans就是答案。  
2、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数（剑指offer）  
同样的，int ans = 0，然后与所有数异或，最后这个ans就是这两个奇数的异或的结果，然后再用int x = lowbit(ans)取得最后一个1包括之后的0，用这个x去异或所有的数，把这些数分成两组，这两组数相互异或，得到的就是m、n这两个出现奇数次的数。  
3、一个数组中有一种数出现K次，其他数都出现了M次，M>1，K<M找到，出现了K次的数，要求，额外空间复杂度0(1)，时间复杂度O(N)。  
准备一个32大小的数组int a\[32\]，把每个数的二进制位分别累加到a中的相应的位置上去。由于k<M，那么用每一位的1的个数莫M，如果不为0，就说明这个出现k次的数在这一位做了贡献，否则没有，做了共享就把这一位记录起来。最后遍历完32位，就得到这个出现k次的数了。  
